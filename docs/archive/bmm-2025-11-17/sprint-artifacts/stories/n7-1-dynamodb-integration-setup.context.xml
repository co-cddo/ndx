<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context XML for Story n7-1: DynamoDB Integration Setup
  Generated by BMAD story-context workflow
  Date: 2025-12-02

  This context provides the implementation team with all necessary
  information to develop the story completely.
-->
<story-context version="1.0">
  <meta>
    <story-id>n7-1-dynamodb-integration-setup</story-id>
    <epic>N-7: DynamoDB Lease Enrichment</epic>
    <created>2025-12-02T00:00:00Z</created>
    <frs-covered>FR-ENRICH-1 through FR-ENRICH-6</frs-covered>
  </meta>

  <!-- ======================================================================
       STORY DEFINITION
       ====================================================================== -->
  <story>
    <as_a>notification system</as_a>
    <i_want>to query the LeaseTable in DynamoDB to retrieve complete lease records</i_want>
    <so_that>I can enrich notifications with full lease context</so_that>

    <acceptance_criteria>
      <criterion id="AC-1" priority="must">
        <description>Given an EventBridge event containing userEmail and uuid fields When the notification Lambda processes it Then it queries DynamoDB LeaseTable using composite key (userEmail PK, uuid SK)</description>
        <test-approach>Unit test with mocked DynamoDB client verifying GetItemCommand parameters</test-approach>
      </criterion>

      <criterion id="AC-2" priority="must">
        <description>And the Lambda IAM role has dynamodb:GetItem permission for LeaseTable</description>
        <test-approach>CDK assertion test validating IAM policy in synthesized CloudFormation</test-approach>
      </criterion>

      <criterion id="AC-3" priority="must">
        <description>And the LeaseTable ARN is stored in environment variable (not hardcoded)</description>
        <test-approach>CDK assertion test verifying LEASE_TABLE_NAME environment variable is set</test-approach>
      </criterion>

      <criterion id="AC-4" priority="must">
        <description>And DynamoDB client is reused across Lambda invocations for connection pooling</description>
        <test-approach>Code review verifying module-level client instantiation (not inside handler)</test-approach>
      </criterion>

      <criterion id="AC-5" priority="must">
        <description>And DynamoDB query latency is logged as CloudWatch metric (EnrichmentQueryLatencyMs)</description>
        <test-approach>Unit test verifying Metrics.addMetric called with correct namespace and metric name</test-approach>
      </criterion>

      <criterion id="AC-6" priority="should">
        <description>And integration test validates query latency &lt; 200ms (p99)</description>
        <test-approach>Integration test with real DynamoDB table measuring actual latency</test-approach>
      </criterion>

      <criterion id="AC-7" priority="must">
        <description>And if userEmail or uuid missing from event, enrichment is skipped with warning log</description>
        <test-approach>Unit test with events missing fields, verify logger.warn called and null returned</test-approach>
      </criterion>

      <criterion id="AC-8" priority="must">
        <description>And if userEmail or uuid are wrong type (not string), enrichment is skipped with warning log</description>
        <test-approach>Unit test with numeric/object field values, verify type check and warning</test-approach>
      </criterion>

      <criterion id="AC-9" priority="must">
        <description>And ProvisionedThroughputExceededException triggers 1 retry with 500ms backoff (other errors fail immediately)</description>
        <test-approach>Unit test mocking throttle exception, verify retry logic with timing</test-approach>
      </criterion>

      <criterion id="AC-10" priority="should">
        <description>And schema fingerprint (sorted field names hash) is logged for drift detection</description>
        <test-approach>Unit test verifying fingerprint generation and logging</test-approach>
      </criterion>
    </acceptance_criteria>

    <tasks>
      <task id="T1" effort="medium">
        <title>Extend enrichment.ts with lease record fetching</title>
        <subtasks>
          <subtask id="T1.1">Add fetchLeaseRecord(userEmail: string, uuid: string) function</subtask>
          <subtask id="T1.2">Implement composite key query with GetItemCommand</subtask>
          <subtask id="T1.3">Ensure DynamoDB client is module-level singleton for connection pooling</subtask>
          <subtask id="T1.4">Add proper TypeScript types for LeaseRecord</subtask>
        </subtasks>
        <covers-acs>AC-1, AC-4</covers-acs>
      </task>

      <task id="T2" effort="small">
        <title>Add CDK infrastructure for DynamoDB access</title>
        <subtasks>
          <subtask id="T2.1">Add LEASE_TABLE_NAME environment variable to Lambda</subtask>
          <subtask id="T2.2">Add dynamodb:GetItem permission for LeaseTable ARN</subtask>
          <subtask id="T2.3">Verify ARN comes from config, not hardcoded</subtask>
        </subtasks>
        <covers-acs>AC-2, AC-3</covers-acs>
      </task>

      <task id="T3" effort="small">
        <title>Implement CloudWatch metrics for query latency</title>
        <subtasks>
          <subtask id="T3.1">Add timing wrapper around DynamoDB query</subtask>
          <subtask id="T3.2">Emit EnrichmentQueryLatencyMs metric with Lambda Powertools Metrics</subtask>
        </subtasks>
        <covers-acs>AC-5</covers-acs>
      </task>

      <task id="T4" effort="small">
        <title>Implement input validation and skip logic</title>
        <subtasks>
          <subtask id="T4.1">Check for missing userEmail or uuid in event detail</subtask>
          <subtask id="T4.2">Check for wrong types (non-string)</subtask>
          <subtask id="T4.3">Log warning and skip enrichment (don't fail notification)</subtask>
        </subtasks>
        <covers-acs>AC-7, AC-8</covers-acs>
      </task>

      <task id="T5" effort="medium">
        <title>Implement throttle retry logic</title>
        <subtasks>
          <subtask id="T5.1">Catch ProvisionedThroughputExceededException</subtask>
          <subtask id="T5.2">Wait 500ms and retry once</subtask>
          <subtask id="T5.3">On second failure, proceed without enrichment</subtask>
        </subtasks>
        <covers-acs>AC-9</covers-acs>
      </task>

      <task id="T6" effort="small">
        <title>Implement schema fingerprint logging</title>
        <subtasks>
          <subtask id="T6.1">Extract and sort field names from returned lease record</subtask>
          <subtask id="T6.2">Create hash of sorted field names</subtask>
          <subtask id="T6.3">Log fingerprint for drift detection monitoring</subtask>
        </subtasks>
        <covers-acs>AC-10</covers-acs>
      </task>

      <task id="T7" effort="medium">
        <title>Write unit tests</title>
        <subtasks>
          <subtask id="T7.1">Test successful lease record fetch</subtask>
          <subtask id="T7.2">Test missing userEmail/uuid handling</subtask>
          <subtask id="T7.3">Test wrong type handling</subtask>
          <subtask id="T7.4">Test throttle retry behavior</subtask>
          <subtask id="T7.5">Test schema fingerprint generation</subtask>
        </subtasks>
        <covers-acs>All</covers-acs>
      </task>

      <task id="T8" effort="medium">
        <title>Write integration test</title>
        <subtasks>
          <subtask id="T8.1">Create integration test with real DynamoDB table</subtask>
          <subtask id="T8.2">Validate query latency &lt; 200ms (p99)</subtask>
        </subtasks>
        <covers-acs>AC-6</covers-acs>
      </task>
    </tasks>
  </story>

  <!-- ======================================================================
       EXISTING CODE ARTIFACTS
       ====================================================================== -->
  <code-artifacts>
    <artifact type="source-to-extend">
      <file-path>infra/lib/lambda/notification/enrichment.ts</file-path>
      <lines>774</lines>
      <purpose>DynamoDB Enrichment Module - extend with lease-specific fetch for Epic N-7</purpose>
      <key-patterns>
        <pattern name="CircuitBreaker">Class at lines 130-198 for DynamoDB throttle protection</pattern>
        <pattern name="queryLeaseTable">Function at lines 218-260 already exists - extend or reuse</pattern>
        <pattern name="handleDynamoDBError">Function at lines 356-370 for error classification</pattern>
        <pattern name="Module-level logger/metrics">Lines 51-55 - reuse for consistency</pattern>
        <pattern name="ENRICHMENT_TIMEOUT_MS">Constant at line 35 = 2000ms</pattern>
        <pattern name="LeaseRecord interface">Lines 65-75 - existing type definition</pattern>
      </key-patterns>
      <critical-interfaces>
        <interface>enrichIfNeeded(event, templateConfig, dynamoClient): Promise&lt;EnrichedData&gt;</interface>
        <interface>queryLeaseTable(dynamoClient, userEmail, uuid, eventId): Promise&lt;LeaseRecord | null&gt;</interface>
        <interface>CircuitBreaker.isOpen(), recordSuccess(), recordFailure()</interface>
      </critical-interfaces>
      <note>The existing queryLeaseTable function already implements composite key query with GetItem. Story 7.1 may primarily need to add: (1) latency metrics, (2) schema fingerprint logging, (3) throttle retry with 500ms backoff, (4) input validation for wrong types.</note>
    </artifact>

    <artifact type="infrastructure">
      <file-path>infra/lib/notification-stack.ts</file-path>
      <lines>825</lines>
      <purpose>CDK stack for notification Lambda - IAM permissions and environment variables</purpose>
      <key-patterns>
        <pattern name="DynamoDB permissions">Lines 207-224 - already grants dynamodb:GetItem to LeaseTable</pattern>
        <pattern name="ISB Config">Lines 197-199, 207 - gets ISB config including table names</pattern>
        <pattern name="Lambda environment">Lines 149-166 - environment variables block</pattern>
      </key-patterns>
      <note>DynamoDB permissions already exist. Story 7.1 needs to add LEASE_TABLE_NAME environment variable.</note>
    </artifact>

    <artifact type="reference">
      <file-path>infra/lib/lambda/notification/ownership.ts</file-path>
      <lines>567</lines>
      <purpose>Email ownership verification - shows existing DynamoDB query patterns</purpose>
      <key-patterns>
        <pattern name="queryLeaseTable">Lines 242-293 - similar GetItem pattern to reuse</pattern>
        <pattern name="hashForLog">Line 130-134 - PII-safe logging helper</pattern>
        <pattern name="Error classification">RetriableError, PermanentError patterns</pattern>
      </key-patterns>
    </artifact>

    <artifact type="configuration">
      <file-path>infra/lib/config.ts</file-path>
      <lines>228</lines>
      <purpose>Environment configuration including ISB table names</purpose>
      <key-patterns>
        <pattern name="ISBConfig interface">Lines 25-53 - includes dynamoDbTables</pattern>
        <pattern name="ISB_CONFIG">Lines 61-82 - actual table names by environment</pattern>
        <pattern name="leaseTable">Line 67 - 'ndx-try-isb-data-LeaseTable473C6DF2-1RC3238PVASE1'</pattern>
      </key-patterns>
    </artifact>

    <artifact type="test-reference">
      <file-path>infra/lib/lambda/notification/enrichment.test.ts</file-path>
      <purpose>Existing enrichment tests - follow patterns for new tests</purpose>
      <note>Check existing test patterns for mocking DynamoDB with aws-sdk-client-mock</note>
    </artifact>
  </code-artifacts>

  <!-- ======================================================================
       DOCUMENTATION ARTIFACTS
       ====================================================================== -->
  <documentation>
    <artifact type="epic">
      <file-path>docs/epics-notifications.md</file-path>
      <relevant-sections>
        <section>Epic 7: DynamoDB Lease Enrichment (lines 807-1068)</section>
        <section>Story 7.1: DynamoDB Integration Setup (lines 815-854)</section>
        <section>FR Coverage Map - FR-ENRICH-1 to FR-ENRICH-6 (lines 754-759)</section>
      </relevant-sections>
    </artifact>

    <artifact type="architecture">
      <file-path>docs/notification-architecture.md</file-path>
      <relevant-sections>
        <section>DynamoDB Access (Read-Only) - lines 1349-1400</section>
        <section>ISB DynamoDB Tables - LeaseTable schema (lines 1349-1377)</section>
        <section>Enrichment Pattern (lines 375-399)</section>
        <section>ADR-004: Read-Only DynamoDB Access (lines 1099-1117)</section>
      </relevant-sections>
    </artifact>
  </documentation>

  <!-- ======================================================================
       DEPENDENCIES
       ====================================================================== -->
  <dependencies>
    <runtime>
      <dependency name="@aws-sdk/client-dynamodb" version="^3.x">DynamoDB client for GetItem operations</dependency>
      <dependency name="@aws-sdk/util-dynamodb" version="^3.x">unmarshall utility for type conversion</dependency>
      <dependency name="@aws-lambda-powertools/logger" version="^2.x">Structured logging with correlation IDs</dependency>
      <dependency name="@aws-lambda-powertools/metrics" version="^2.x">CloudWatch custom metrics</dependency>
    </runtime>
    <dev>
      <dependency name="aws-sdk-client-mock" version="^4.x">Mock DynamoDB for unit tests</dependency>
      <dependency name="jest" version="^29.x">Test framework</dependency>
    </dev>
  </dependencies>

  <!-- ======================================================================
       TECHNICAL CONSTRAINTS
       ====================================================================== -->
  <constraints>
    <constraint type="timeout">
      <description>Enrichment timeout budget is 2 seconds (from existing ENRICHMENT_TIMEOUT_MS constant)</description>
      <source>enrichment.ts:35</source>
    </constraint>

    <constraint type="retry">
      <description>Only retry ProvisionedThroughputExceededException, not other DynamoDB errors</description>
      <backoff>500ms fixed delay, 1 retry max</backoff>
    </constraint>

    <constraint type="graceful-degradation">
      <description>Notification MUST proceed even if enrichment fails - never block notification</description>
    </constraint>

    <constraint type="connection-pooling">
      <description>DynamoDB client must be module-level singleton (not inside handler) for connection reuse</description>
    </constraint>

    <constraint type="consistency">
      <description>Use ConsistentRead: true for all DynamoDB queries (existing pattern)</description>
    </constraint>

    <constraint type="same-account">
      <description>Lambda and LeaseTable are in same AWS account - no cross-account IAM needed</description>
    </constraint>
  </constraints>

  <!-- ======================================================================
       TESTING STANDARDS
       ====================================================================== -->
  <testing>
    <standard name="mocking">
      <description>Mock DynamoDB with aws-sdk-client-mock package</description>
      <example>
const { mockClient } = require('aws-sdk-client-mock');
const { DynamoDBClient, GetItemCommand } = require('@aws-sdk/client-dynamodb');
const ddbMock = mockClient(DynamoDBClient);

ddbMock.on(GetItemCommand).resolves({
  Item: { userEmail: { S: 'test@gov.uk' }, uuid: { S: '123' } }
});
      </example>
    </standard>

    <standard name="metrics-testing">
      <description>Verify Metrics.addMetric calls with jest.spyOn</description>
      <example>
const metricsSpy = jest.spyOn(metrics, 'addMetric');
await fetchLeaseRecord('user@gov.uk', 'uuid-123');
expect(metricsSpy).toHaveBeenCalledWith(
  'EnrichmentQueryLatencyMs',
  MetricUnit.Milliseconds,
  expect.any(Number)
);
      </example>
    </standard>

    <standard name="timing-tests">
      <description>Use jest.useFakeTimers() for throttle retry timing tests</description>
    </standard>

    <standard name="existing-patterns">
      <description>Follow patterns in enrichment.test.ts and ownership.test.ts</description>
    </standard>
  </testing>

  <!-- ======================================================================
       ELICITATION INSIGHTS (From Advanced Elicitation)
       ====================================================================== -->
  <elicitation-insights>
    <pre-mortem>
      <risk id="PM-1" likelihood="high" impact="medium">
        <description>LeaseTable schema drift causes unmarshall failures</description>
        <mitigation>Schema fingerprint logging (AC-10) enables early detection via CloudWatch alerts on fingerprint changes</mitigation>
      </risk>
      <risk id="PM-2" likelihood="medium" impact="high">
        <description>DynamoDB throttling during spike causes cascade failures</description>
        <mitigation>Circuit breaker pattern already exists (lines 130-198), plus 500ms backoff retry (AC-9)</mitigation>
      </risk>
    </pre-mortem>

    <five-whys>
      <finding id="FW-1">
        <question>Why do we need composite key query?</question>
        <answer>LeaseTable uses userEmail (PK) + uuid (SK) as unique identifier - must query both to get specific lease</answer>
      </finding>
      <finding id="FW-2">
        <question>Why 500ms backoff for throttle retry?</question>
        <answer>DynamoDB throttles recover quickly (&lt;1s typically), 500ms gives time without blocking notification too long</answer>
      </finding>
    </five-whys>

    <devils-advocate>
      <challenge id="DA-1">
        <question>What if userEmail/uuid are present but wrong type?</question>
        <resolution>AC-8 requires type checking - skip with warning if not strings, don't let JSON parsing errors crash handler</resolution>
      </challenge>
      <challenge id="DA-2">
        <question>What if LeaseTable doesn't exist?</question>
        <resolution>Existing handleDynamoDBError throws PermanentError for ResourceNotFoundException - goes to DLQ</resolution>
      </challenge>
    </devils-advocate>

    <journey-mapping>
      <touchpoint id="JM-1">
        <stage>Event arrives</stage>
        <action>Extract userEmail and uuid from event.detail.leaseId</action>
        <notes>Some events have leaseId as object, some as string - handle both</notes>
      </touchpoint>
      <touchpoint id="JM-2">
        <stage>Validate inputs</stage>
        <action>Check userEmail/uuid present and are strings</action>
        <notes>Skip enrichment (don't fail) if invalid - notification must proceed</notes>
      </touchpoint>
      <touchpoint id="JM-3">
        <stage>Query DynamoDB</stage>
        <action>GetItem with composite key, ConsistentRead: true</action>
        <notes>Time the query, emit latency metric</notes>
      </touchpoint>
      <touchpoint id="JM-4">
        <stage>Handle throttle</stage>
        <action>Catch ProvisionedThroughputExceededException, wait 500ms, retry once</action>
        <notes>Other errors go to circuit breaker immediately</notes>
      </touchpoint>
      <touchpoint id="JM-5">
        <stage>Process result</stage>
        <action>Generate schema fingerprint, return LeaseRecord or null</action>
        <notes>Log fingerprint for drift detection dashboard</notes>
      </touchpoint>
    </journey-mapping>

    <risk-matrix>
      <risk id="RM-1" likelihood="low" impact="critical">
        <description>Credentials leak in logs</description>
        <mitigation>Never log raw email addresses - use hashForLog() from ownership.ts</mitigation>
      </risk>
      <risk id="RM-2" likelihood="medium" impact="medium">
        <description>Latency exceeds 200ms p99</description>
        <mitigation>Same-region DynamoDB, connection pooling, metric alerting on AC-6 threshold</mitigation>
      </risk>
    </risk-matrix>
  </elicitation-insights>

  <!-- ======================================================================
       IMPLEMENTATION GUIDANCE
       ====================================================================== -->
  <implementation-guidance>
    <recommendation priority="1">
      <title>Extend existing queryLeaseTable function</title>
      <details>
        The existing queryLeaseTable function at enrichment.ts:218-260 already implements the
        composite key GetItem query. For Story 7.1, consider:
        1. Adding latency timing around the query
        2. Adding schema fingerprint generation after successful fetch
        3. Adding the throttle retry logic (currently goes straight to circuit breaker)
        4. Adding type validation for userEmail/uuid inputs
      </details>
    </recommendation>

    <recommendation priority="2">
      <title>Add LEASE_TABLE_NAME environment variable</title>
      <details>
        In notification-stack.ts, add to the Lambda environment block (around line 165):
        LEASE_TABLE_NAME: isbConfig.dynamoDbTables.leaseTable

        The table name already comes from config.ts, just needs to be passed to Lambda.
      </details>
    </recommendation>

    <recommendation priority="3">
      <title>Create new fetchLeaseRecord wrapper function</title>
      <details>
        Consider creating a new fetchLeaseRecord function that:
        1. Validates inputs (userEmail, uuid must be strings)
        2. Calls existing queryLeaseTable with timing
        3. Implements the 500ms throttle retry
        4. Generates and logs schema fingerprint
        5. Emits EnrichmentQueryLatencyMs metric

        This keeps queryLeaseTable focused on the raw DynamoDB operation.
      </details>
    </recommendation>

    <recommendation priority="4">
      <title>Schema fingerprint implementation</title>
      <details>
        For AC-10, implement fingerprint as:
        1. Get all keys from lease record: Object.keys(leaseRecord).sort()
        2. Join with comma: keys.join(',')
        3. Hash with SHA-256: createHash('sha256').update(keyList).digest('hex').substring(0, 16)
        4. Log as: logger.info('Schema fingerprint', { eventId, fingerprint, keyCount: keys.length })

        This enables CloudWatch Insights query for fingerprint changes over time.
      </details>
    </recommendation>
  </implementation-guidance>
</story-context>
