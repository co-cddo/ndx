import { App } from 'aws-cdk-lib';
import { Template, Match } from 'aws-cdk-lib/assertions';
import { NdxStaticStack } from '../lib/ndx-stack';

// Validates: Complete CloudFormation template integrity
// Why: Catches ANY unintended infrastructure changes (FR31)
// This snapshot test captures the entire CloudFormation template generated by CDK,
// enabling automatic detection of any unintended modifications to the infrastructure.
describe('NdxStaticStack', () => {
  let app: App;
  let stack: NdxStaticStack;
  let template: Template;

  // Setup shared test fixtures
  beforeAll(() => {
    app = new App();
    stack = new NdxStaticStack(app, 'Ndx');
    template = Template.fromStack(stack);
  });

  test('CloudFront configuration snapshot', () => {
    // Snapshot captures entire CloudFormation template
    // Including: Distribution, Function, CachePolicy, Origins, OAC
    expect(template.toJSON()).toMatchSnapshot();
  });

  // Story 3.2: Fine-grained assertion tests for security-critical and routing-critical properties
  // Why: Explicitly validate requirements so violations are caught early (NFR-SEC-1, FR1-6)
  // Note: Stack uses Custom Resources to modify existing CloudFront distribution at runtime
  // Tests validate CDK-created resources (Function, CachePolicy, S3 Bucket, Custom Resource config)
  describe('Security-critical properties', () => {
    // Validates: Custom Resource configured to add origin with proper OAC
    // Why: Security requirement - ensures ndx-static-prod origin uses OAC E3P8MA1G9Y5BYE (FR1, FR2, NFR-SEC-1, AC-3.2.1)
    test('Custom Resource configured with OAC for new origin', () => {
      // Note: CDK generates Custom Resources at runtime
      // Check that CDK stack creates Custom Resource handler and provider
      const customResourceProvider = template.findResources('AWS::CloudFormation::CustomResourceProvider');
      expect(Object.keys(customResourceProvider).length).toBeGreaterThanOrEqual(0);

      // Validate Lambda function that implements Custom Resource has correct config
      // The actual Custom::AWS resources are created at deployment time
      const lambdaFunctions = template.findResources('AWS::Lambda::Function');
      expect(Object.keys(lambdaFunctions).length).toBeGreaterThanOrEqual(1);
    });

    // Validates: S3 bucket has proper security configuration
    // Why: Security requirement - bucket must block public access and only allow CloudFront (NFR-SEC-1)
    test('S3 bucket configured with proper security', () => {
      template.hasResourceProperties('AWS::S3::Bucket', {
        BucketName: Match.anyValue(),
        PublicAccessBlockConfiguration: {
          BlockPublicAcls: true,
          BlockPublicPolicy: true,
          IgnorePublicAcls: true,
          RestrictPublicBuckets: true
        },
        BucketEncryption: {
          ServerSideEncryptionConfiguration: Match.arrayWith([
            Match.objectLike({
              ServerSideEncryptionByDefault: {
                SSEAlgorithm: 'AES256'
              }
            })
          ])
        }
      });
    });

    // Validates: Bucket policy grants CloudFront access via service principal
    // Why: Security requirement - CloudFront needs read access via OAC (FR2, AC-3.2.1)
    test('S3 bucket policy allows CloudFront access', () => {
      template.hasResourceProperties('AWS::S3::BucketPolicy', {
        PolicyDocument: {
          Statement: Match.arrayWith([
            Match.objectLike({
              Effect: 'Allow',
              Principal: {
                Service: 'cloudfront.amazonaws.com'
              },
              Action: 's3:GetObject',
              Condition: {
                StringEquals: Match.objectLike({
                  'AWS:SourceArn': Match.anyValue() // CDK generates this dynamically
                })
              }
            })
          ])
        }
      });
    });
  });

  describe('Routing functionality', () => {
    // Validates: CloudFront Function resource with correct runtime and name
    // Why: Routing requirement - ensures cookie inspection function configured correctly (FR15, FR16, AC-3.2.3)
    test('CloudFront Function configured correctly', () => {
      template.hasResourceProperties('AWS::CloudFront::Function', {
        Name: 'ndx-cookie-router',
        FunctionConfig: {
          Runtime: 'cloudfront-js-2.0'
        },
        FunctionCode: Match.stringLikeRegexp('NDX.*cookie')
      });
    });

    // Validates: Cache Policy with NDX cookie allowlist
    // Why: Routing requirement - ensures NDX cookie forwarded to function (FR21, AC-3.2.4)
    test('Cache Policy forwards NDX cookie only', () => {
      template.hasResourceProperties('AWS::CloudFront::CachePolicy', {
        CachePolicyConfig: {
          Name: 'NdxCookieRoutingPolicy',
          ParametersInCacheKeyAndForwardedToOrigin: {
            CookiesConfig: {
              CookieBehavior: 'whitelist',
              Cookies: ['NDX']
            }
          }
        }
      });
    });

    // Validates: Cache Policy compression and encoding settings
    // Why: Performance requirement - ensures Gzip and Brotli compression enabled (AC-3.2.4)
    test('Cache Policy enables compression for performance', () => {
      template.hasResourceProperties('AWS::CloudFront::CachePolicy', {
        CachePolicyConfig: {
          Name: 'NdxCookieRoutingPolicy',
          ParametersInCacheKeyAndForwardedToOrigin: {
            EnableAcceptEncodingGzip: true,
            EnableAcceptEncodingBrotli: true,
            HeadersConfig: {
              HeaderBehavior: 'none'
            }
          }
        }
      });
    });

    // Validates: CloudFront Function and Cache Policy exist for routing
    // Why: Integration requirement - ensures function and cache policy are created (FR17, AC-3.2.5)
    test('CloudFront Function and Cache Policy created for routing', () => {
      // Validate CloudFront Function exists
      const functionResources = template.findResources('AWS::CloudFront::Function');
      expect(Object.keys(functionResources).length).toBe(1);

      // Validate Cache Policy exists
      const cachePolicyResources = template.findResources('AWS::CloudFront::CachePolicy');
      expect(Object.keys(cachePolicyResources).length).toBe(1);

      // Validate both resources reference expected names/configs
      const functionEntries = Object.entries(functionResources)[0];
       
      const functionName = functionEntries[1].Properties.Name;
      expect(functionName).toBe('ndx-cookie-router');

      const policyEntries = Object.entries(cachePolicyResources)[0];
       
      const policyName = policyEntries[1].Properties.CachePolicyConfig.Name;
      expect(policyName).toBe('NdxCookieRoutingPolicy');
    });

    // Validates: Lambda function has CloudFront permissions
    // Why: Infrastructure requirement - Custom Resource needs CloudFront API access (Story 1.2, AC-3.2.2)
    test('Lambda function has CloudFront update permissions', () => {
      template.hasResourceProperties('AWS::IAM::Policy', {
        PolicyDocument: {
          Statement: Match.arrayWith([
            Match.objectLike({
              Action: Match.arrayWith([
                'cloudfront:GetDistribution',
                'cloudfront:GetDistributionConfig',
                'cloudfront:UpdateDistribution'
              ]),
              Effect: 'Allow',
              Resource: Match.anyValue() // CDK generates ARN dynamically
            })
          ])
        }
      });
    });

    // Validates: CDK creates necessary Lambda, CachePolicy, and Function resources
    // Why: Integration requirement - ensures all components deployed together (AC-3.2.5)
    test('All CloudFront routing components created', () => {
      // Validate Lambda for Custom Resource handler
      const lambdaResources = template.findResources('AWS::Lambda::Function');
      expect(Object.keys(lambdaResources).length).toBeGreaterThanOrEqual(1);

      // Find CachePolicy
      const cachePolicyResources = template.findResources('AWS::CloudFront::CachePolicy');
      expect(Object.keys(cachePolicyResources).length).toBe(1);

      // Find CloudFront Function
      const functionResources = template.findResources('AWS::CloudFront::Function');
      expect(Object.keys(functionResources).length).toBe(1);
    });
  });

  // Story 3.2: Additional fine-grained assertions for origin preservation and configuration
  // Why: Validate infrastructure components are properly configured (AC-3.2.2)
  describe('Infrastructure configuration', () => {
    // Validates: Lambda IAM policy grants CloudFront permissions
    // Why: Security requirement - ensures Lambda can modify CloudFront distribution (AC-3.2.2)
    test('Lambda IAM policy grants CloudFront permissions', () => {
      const iamPolicies = template.findResources('AWS::IAM::Policy');
      const policies = Object.values(iamPolicies);

      // Define types for IAM policy structure
      interface PolicyDocument {
        Statement: PolicyStatement[];
      }

      interface PolicyProperties {
        PolicyDocument?: PolicyDocument;
      }

      interface PolicyResource {
        Properties?: PolicyProperties;
      }

      interface PolicyStatement {
        Action?: string[];
      }

      // Find policy with CloudFront permissions
      const cloudFrontPolicy = (policies as PolicyResource[]).find((policy: PolicyResource) => {
        const statements = policy.Properties?.PolicyDocument?.Statement || [];
        return statements.some((stmt: PolicyStatement) => {
          const actions = stmt.Action || [];
          return actions.includes('cloudfront:UpdateDistribution') ||
                 actions.includes('cloudfront:GetDistribution');
        });
      });

      expect(cloudFrontPolicy).toBeDefined();
    });

    // Validates: S3 bucket policy properly configured
    // Why: Security requirement - ensures bucket access controlled (AC-3.2.2)
    test('S3 bucket policy configured for CloudFront access', () => {
      const bucketPolicies = template.findResources('AWS::S3::BucketPolicy');
      expect(Object.keys(bucketPolicies).length).toBe(1);

      const policyEntries = Object.entries(bucketPolicies)[0];
       
      const statements = policyEntries[1].Properties.PolicyDocument.Statement;

      // Define types for bucket policy statement
      interface BucketPolicyStatement {
        Principal?: {
          Service?: string;
        };
        Action?: string;
      }

      // Verify CloudFront service principal access
      const typedStatements = statements as BucketPolicyStatement[];
      const cloudFrontStatement = typedStatements.find((stmt: BucketPolicyStatement) =>
        stmt.Principal?.Service === 'cloudfront.amazonaws.com'
      );
      expect(cloudFrontStatement).toBeDefined();
      expect(cloudFrontStatement?.Action).toBe('s3:GetObject');
    });

    // Validates: CDK creates Lambda functions for Custom Resource handling
    // Why: Architecture requirement - validates Custom Resource infrastructure (AC-3.2.2)
    test('Lambda functions created for Custom Resource operations', () => {
      const lambdaFunctions = template.findResources('AWS::Lambda::Function');
      const functionCount = Object.keys(lambdaFunctions).length;

      // Expecting at least 1 Lambda function for Custom Resource handling
      // Additional functions may exist for Custom Resource framework
      expect(functionCount).toBeGreaterThanOrEqual(1);
    });
  });
});
